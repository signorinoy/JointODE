---
title: "Data Simulation"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Data Simulation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```

This vignette demonstrates how to simulate data from a joint ODE model that combines longitudinal biomarker trajectories with survival outcomes. The framework generates realistic clinical data where biomarker dynamics influence event times through a shared random effect structure.

## Review of Model Setup

### Longitudinal Model

The biomarker evolution follows a second-order ODE system:

$$\ddot{m}_i(t) = g(\boldsymbol{\beta}^{\top}\mathbf{Z}_i(t))$$

where:

- $m_i(t)$: Latent biomarker trajectory for subject $i$
- $\mathbf{Z}_i(t) = (m_i(t), \dot{m}_i(t), \mathbf{X}_i(t)^{\top}, t)^{\top}$: Augmented state vector with position, velocity, covariates, and time

Observed measurements:

$$V_{ij} = m_i(T_{ij}) + b_i + \varepsilon_{ij}$$

with $b_i \sim N(0, \sigma_b^2)$ (random intercept) and $\varepsilon_{ij} \sim N(0, \sigma_e^2)$ (measurement error).

### Survival Model

The hazard function incorporates trajectory dynamics:

$$\lambda_i(t|b_i) = \lambda_0(t) \exp[\boldsymbol{\alpha}^{\top}\mathbf{m}_i(t) + \mathbf{W}_i^{\top}\boldsymbol{\phi} + b_i]$$

where:

- $\lambda_0(t)$ baseline hazard function
- $\mathbf{m}_i(t) = (m_i(t), \dot{m}_i(t), \ddot{m}_i(t))^{\top}$: Trajectory features (value, velocity, acceleration)
- $\mathbf{W}_i$: Baseline covariates
- $b_i$: Subject-specific random intercept

## Parameter Specification

### Key Parameters

| Component | Parameter | Value | Description |
|-----------|-----------|-------|-------------|
| **ODE Dynamics** | | | |
| | $\beta_1$ | -0.3 | Negative feedback (homeostasis) |
| | $\beta_2$ | -0.5 | Damping coefficient |
| | $\beta_3$ | 0.2 | Treatment effect |
| | $\beta_4$ | 0.1 | Seasonal effect |
| | $\beta_5$ | 0.05 | Time trend |
| | $g(u)$    | $0.5\tanh(u/3)$ | Bounded nonlinear link function |
| **Random Effects** | | | |
| | $\sigma_b$ | 0.5 | Between-subject SD |
| | $\sigma_e$ | 0.1 | Measurement error SD |
| **Survival** | | | |
| | $\kappa$ | 1.5 | Weibull shape |
| | $\theta$ | 8 | Weibull scale |
| | $\alpha$ | (0.3, 0.1, -0.05) | Association parameters |
| | $\phi$ | (0.2, -0.15) | Covariate effects |
| **Covariates** | | | |
| | $X_1(t)$ | $e^{-t/5}$ | Treatment decay |
| | $X_2(t)$ | $0.2\sin(2\pi t)$ | Seasonal effect |

## Implementation

### Dependencies and Setup

```{r setup, message=FALSE, warning=FALSE}
# Load required packages
library(deSolve) # ODE numerical integration
library(simsurv) # Flexible survival simulation
library(ggplot2) # Visualization

# Set random seed for reproducibility
set.seed(123)
```

### Parameter Configuration

```{r params}
#' Configure simulation parameters
#'
#' @param n Sample size
#' @param sigma_b Random effect standard deviation
#' @param sigma_e Measurement error standard deviation
#' @param alpha Association parameters (3-vector)
#' @param beta Index weights (5-vector, normalized internally)
#' @param phi Baseline covariate effects (2-vector)
#' @return List of simulation parameters
setup_simulation_params <- function(
    n = 200,
    sigma_b = 0.5,
    sigma_e = 0.1,
    alpha = c(0.3, 0.1, -0.05),
    beta = c(-0.3, -0.5, 0.2, 0.1, 0.05),
    phi = c(0.2, -0.15)) {
  # Normalize beta for identifiability
  beta_norm <- beta / sqrt(sum(beta^2))

  list(
    n = n,
    sigma_b = sigma_b,
    sigma_e = sigma_e,
    alpha = alpha,
    beta = beta_norm,
    phi = phi
  )
}
```

### Core Model Functions

```{r functions}
#' Nonlinear link function
#'
#' @param u Single index value
#' @return Transformed value in [-0.5, 0.5]
g_function <- function(u) {
  0.5 * tanh(u / 3)
}

#' Weibull baseline hazard
#'
#' @param t Time point
#' @param shape Shape parameter (>1 for increasing hazard)
#' @param scale Scale parameter
#' @return Hazard value at time t
baseline_hazard <- function(t, shape = 1.5, scale = 8) {
  (shape / scale) * (t / scale)^(shape - 1)
}
```

### ODE System Definition

```{r ode-system}
#' ODE system for biomarker dynamics
#'
#' @param t Current time
#' @param state State vector [m, m_dot]
#' @param params List containing beta, X_func, g_func
#' @return List of derivatives
ode_system <- function(t, state, params) {
  m <- state[1] # Position
  m_dot <- state[2] # Velocity

  # Time-varying covariates
  x_t <- if (!is.null(params$x_func)) {
    params$x_func(t)
  } else {
    c(0, 0)
  }

  # Augmented state vector
  z <- c(m, m_dot, x_t, t)

  # Single index model
  u <- sum(params$beta * z)
  m_ddot <- params$g_func(u)

  list(c(m_dot, m_ddot))
}
```

### Trajectory Generation

```{r generate-trajectory}
#' Generate individual trajectory
#'
#' @param i Subject index
#' @param params Simulation parameters
#' @param tmax Maximum follow-up time
#' @return List with trajectory functions and data
generate_trajectory <- function(i, params, tmax = 10) {
  # Random effect
  b_i <- rnorm(1, 0, params$sigma_b)

  # Baseline covariates
  w_i <- c(
    rnorm(1, 0, 1), # Continuous (e.g., age)
    rbinom(1, 1, 0.5) # Binary (e.g., treatment)
  )

  # Time-varying covariate functions
  x_func <- function(t) {
    c(
      exp(-t / 5), # Treatment decay
      0.2 * sin(2 * pi * t) # Seasonal effect
    )
  }

  # Initial conditions
  m_0 <- 0
  m_dot_0 <- 0

  # ODE parameters
  ode_params <- list(
    beta = params$beta,
    x_func = x_func,
    g_func = g_function
  )

  # Numerical integration
  times <- seq(0, tmax, by = 0.05)
  sol <- ode(
    y = c(m = m_0, m_dot = m_dot_0),
    times = times,
    func = ode_system,
    parms = ode_params,
    method = "lsoda"
  )

  # Interpolation functions
  m_func <- approxfun(sol[, 1], sol[, 2], rule = 2)
  m_dot_func <- approxfun(sol[, 1], sol[, 3], rule = 2)

  # Acceleration computation
  x_vals <- t(sapply(sol[, 1], x_func))
  z_mat <- cbind(sol[, 2], sol[, 3], x_vals, sol[, 1])
  u_vals <- z_mat %*% params$beta
  m_ddot_vals <- g_function(as.vector(u_vals))
  m_ddot_func <- approxfun(sol[, 1], m_ddot_vals, rule = 2)

  list(
    id = i,
    b_i = b_i,
    w_i = w_i,
    x_func = x_func,
    m_func = m_func,
    m_dot_func = m_dot_func,
    m_ddot_func = m_ddot_func,
    trajectory = as.data.frame(sol)
  )
}
```

### Survival Time Generation

```{r survival-times}
#' Generate survival times using simsurv
#'
#' @param trajectories List of trajectory objects
#' @param params Simulation parameters
#' @return Data frame with survival times and censoring indicators
generate_survival_times <- function(trajectories, params) {
  # Covariate data
  covdat <- data.frame(
    id = seq_along(trajectories),
    b_i = sapply(trajectories, function(x) x$b_i),
    w1 = sapply(trajectories, function(x) x$w_i[1]),
    w2 = sapply(trajectories, function(x) x$w_i[2])
  )

  # Time-dependent hazard
  hazard_func <- function(t, x, betas, ...) {
    idx <- round(as.numeric(x["id"]))
    traj <- trajectories[[idx]]

    # Trajectory evaluation
    m_t <- traj$m_func(t)
    m_dot_t <- traj$m_dot_func(t)
    m_ddot_t <- traj$m_ddot_func(t)

    # Hazard computation
    h0 <- baseline_hazard(t, shape = 1.5, scale = 8)

    log_hazard <- log(h0) +
      params$alpha[1] * m_t +
      params$alpha[2] * m_dot_t +
      params$alpha[3] * m_ddot_t +
      x["b_i"] +
      betas["w1"] * x["w1"] +
      betas["w2"] * x["w2"]

    exp(log_hazard)
  }

  # Generate event times
  surv_times <- simsurv(
    hazard = hazard_func,
    x = covdat,
    betas = c(w1 = params$phi[1], w2 = params$phi[2]),
    maxt = 10,
    interval = c(1e-8, 15)
  )

  # Administrative censoring
  cens_times <- runif(
    nrow(covdat),
    min = quantile(surv_times$eventtime, 0.5),
    max = quantile(surv_times$eventtime, 0.95)
  )

  surv_times$obstime <- pmin(surv_times$eventtime, cens_times)
  surv_times$status <- as.numeric(surv_times$eventtime <= cens_times)

  surv_times
}
```

### Longitudinal Measurement Process

```{r longitudinal-data}
#' Generate longitudinal measurements
#'
#' @param trajectories List of trajectory objects
#' @param surv_times Survival data frame
#' @param params Simulation parameters
#' @return Data frame with longitudinal observations
generate_longitudinal_data <- function(trajectories, surv_times, params) {
  long_data <- list()

  for (i in seq_along(trajectories)) {
    traj <- trajectories[[i]]
    t_i <- surv_times$obstime[i]

    # Measurement schedule
    if (t_i <= 2) {
      visit_times <- seq(0, t_i, by = 0.25)
    } else {
      quarterly <- seq(0, 2, by = 0.25)
      if (t_i > 2.5) {
        semiannual <- seq(2.5, t_i, by = 0.5)
        visit_times <- c(quarterly, semiannual)
      } else {
        visit_times <- quarterly
      }
    }

    # Introduce random missingness
    visit_times <- visit_times[runif(length(visit_times)) > 0.1]

    # Ensure baseline measurement
    if (length(visit_times) == 0) visit_times <- 0

    # Measurements with error and covariates
    measurements <- numeric(length(visit_times))
    x1_obs <- numeric(length(visit_times))
    x2_obs <- numeric(length(visit_times))

    for (j in seq_along(visit_times)) {
      m_true <- traj$m_func(visit_times[j])
      measurements[j] <- m_true + traj$b_i + rnorm(1, 0, params$sigma_e)

      # Store covariate values at observation times
      x_vals <- traj$x_func(visit_times[j])
      x1_obs[j] <- x_vals[1]
      x2_obs[j] <- x_vals[2]
    }

    long_data[[i]] <- data.frame(
      id = traj$id,
      time = visit_times,
      value = measurements,
      x1 = x1_obs, # Treatment effect
      x2 = x2_obs, # Seasonal effect
      b_true = traj$b_i
    )
  }

  do.call(rbind, long_data)
}
```

### Main Simulation Interface

```{r main-simulation}
#' Simulate joint ODE model data
#'
#' @param n Sample size
#' @param seed Random seed
#' @return List containing longitudinal and survival datasets
simulate_joint_ode_data <- function(n = 200, seed = 123) {
  set.seed(seed)

  # Initialize
  params <- setup_simulation_params(n = n)

  # Generate trajectories
  message("Step 1/3: Generating ODE trajectories...")
  trajectories <- lapply(seq_len(n), generate_trajectory, params = params)

  # Generate survival
  message("Step 2/3: Generating survival times...")
  surv_data <- generate_survival_times(trajectories, params)

  # Report censoring
  actual_censoring <- 1 - mean(surv_data$status)
  message(sprintf("  Achieved censoring: %.1f%%", actual_censoring * 100))

  # Generate longitudinal
  message("Step 3/3: Generating longitudinal data...")
  long_data <- generate_longitudinal_data(trajectories, surv_data, params)

  # Merge covariates
  baseline_data <- data.frame(
    id = seq_len(n),
    w1 = sapply(trajectories, function(x) x$w_i[1]),
    w2 = sapply(trajectories, function(x) x$w_i[2]),
    b_true = sapply(trajectories, function(x) x$b_i)
  )

  surv_data <- merge(surv_data, baseline_data, by = "id")

  # Return datasets
  structure(
    list(
      long_data = long_data,
      surv_data = surv_data,
      params = params,
      trajectories = trajectories
    ),
    class = "joint_ode_data"
  )
}
```

## Usage Example

```{r example-usage}
# Generate synthetic dataset
sim_data <- simulate_joint_ode_data(n = 200, seed = 123)

# Extract components
long_data <- sim_data$long_data
surv_data <- sim_data$surv_data

# Dataset overview
cat("\n========== Dataset Summary ==========\n")
cat(sprintf("Total subjects: %d\n", nrow(surv_data)))
cat(sprintf("Total observations: %d\n", nrow(long_data)))
cat(sprintf(
  "Avg obs/subject: %.1f (range: %d-%d)\n",
  nrow(long_data) / nrow(surv_data),
  min(table(long_data$id)),
  max(table(long_data$id))
))

cat("\n---------- Event Statistics ----------\n")
cat(sprintf(
  "Events: %d (%.1f%%)\n",
  sum(surv_data$status),
  mean(surv_data$status) * 100
))
cat(sprintf(
  "Censored: %d (%.1f%%)\n",
  sum(1 - surv_data$status),
  mean(1 - surv_data$status) * 100
))

cat("\n---------- Follow-up Time ----------\n")
cat(sprintf("Median: %.2f years\n", median(surv_data$obstime)))
cat(sprintf(
  "Range: %.2f - %.2f years\n",
  min(surv_data$obstime),
  max(surv_data$obstime)
))

cat("\n---------- Data Structure ----------\n")
cat("Longitudinal columns:", paste(names(long_data), collapse = ", "), "\n")
cat("Survival columns:", paste(names(surv_data), collapse = ", "), "\n")
```

## Visualization

```{r plot-trajectories, fig.cap="Representative trajectories", fig.width=8, fig.height=6}
# Select subjects
set.seed(123)
sample_ids <- sample(unique(long_data$id), 6)
plot_data <- long_data[long_data$id %in% sample_ids, ]
plot_data <- merge(
  plot_data,
  surv_data[, c("id", "obstime", "status")],
  by = "id"
)

# Create plot
ggplot(plot_data, aes(x = time, y = value)) +
  geom_line(aes(color = factor(id)), alpha = 0.7, linewidth = 0.8) +
  geom_point(aes(color = factor(id)), size = 1.5, alpha = 0.8) +
  geom_vline(
    data = unique(plot_data[, c("id", "obstime", "status")]),
    aes(xintercept = obstime, linetype = factor(status)),
    alpha = 0.4, linewidth = 0.7
  ) +
  scale_linetype_manual(
    values = c("0" = "dashed", "1" = "solid"),
    labels = c("Censored", "Event"),
    name = "Outcome"
  ) +
  facet_wrap(~ paste("Subject", id), scales = "free_y", ncol = 3) +
  labs(
    x = "Time (years)",
    y = "Biomarker Value",
    title = "Simulated Longitudinal Trajectories",
    subtitle = "Vertical lines: event (solid) or censoring (dashed)"
  ) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(fill = "gray95", color = NA),
    strip.text = element_text(face = "bold")
  ) +
  guides(color = "none")
```
